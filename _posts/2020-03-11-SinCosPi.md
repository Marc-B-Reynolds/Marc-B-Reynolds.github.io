---
layout:       post
title:        A design and implementation of sincospi in binary32
categories:   [math]
tags:         [trig,approximation]
description:  Walks through constructing faithfully rounded $\sin\left(\pi x\right)$ and $\cos\left(\pi x\right)$.
plotly: true
---

\\
I'm going do a quick run through of a design and implementation (in binary32 aka single precision) of a method to simultaneously compute:

$$ \begin{align*}
\sin\left(\pi a\right) \\
\cos\left(\pi a\right)
\end{align*} $$

\\
which is going to contain both minimal details and validation.

* non rigorous: don't care about how float-point sticky flags are effected nor about how the how sign of zeroes, NaNs and infinities pan out.
* highly accurate: target "faithfully rounded" (error less than 1 ULP)
* no limit on input range (ok..caveats. see below)
* high throughput computation
* branch-free: both so input can be effectively random (not burdened by branch mispreditions) and can be directly extended to SIMD.

I'm going to assume basic familiarity with polynomial (and in particular minimax) approximations. Robin Green has some very accessible introductory material[^rgreen] on this topic. I'm going to use Sollya[^sollya] which is a freely available library and DSL to build the core approximations. An additional assumption is that the target hardware has fused multiply accumulate[^fma] (FMA) hardware and the used language & compiler support generating them.

Given that we're not working with a limited input range we can't simply brute force the approximation and must:

1. Perform a range reduction
2. Compute the approximation on the reduce range
3. Perform the required "fixed-up" to undo the range reduction

So we have our first trade-off knob to turn: a smaller range makes the function easier to approximate and the flip side is the amount of work required to get that smaller range. The great news is both sine and cosine are pretty easy functions to approximate so we don't need to reduce the range by much. Also the range reduction for the $\pi$ variants isn't the PITA of the standard versions. 

Throughout this post I'm going to be structuring the code in an awkward way which is intended to help visualize operations which can be performed in parallel.

<br>

------

Approximate the primary range
------

\\
Let's run with the reduced range of $a \in \left[-\frac{1}{4},~\frac{1}{4}\right] $. A minimal sollya script to generate the approximations:


      S = fpminimax(sin(pi*x), [|1,3,5,7|],   [|24...|], [0;1/4], floating, relative);
      C = fpminimax(cos(pi*x), [|0,2,4,6,8|], [|24...|], [0;1/4], floating, relative);

\\
The actual script used is slightly more complex and can be found (along with generated output) [here](https://gist.github.com/Marc-B-Reynolds/2d2cc661f5fe771e68d1fcf62007790f). Additionally there's a brief summary of the output at the end of this post.

The inputs are: function to approximate, explicit list of mononomials to use, number of significand bits per component (24 for all), range, floating point (instead of fixed point) coefficients and optimize for relative error. A perhaps noteworthy item is the monomial list which means we don't need rewrite the function and work out a modified range (which is needed for some software tools).

The sine and cosine approximations generated by the mini script above have errors less than $2^{-27}$ and $2^{-30}$ respectively so both of these should be good for our target.  Let's take the output and shove it into a code fragment which evaluates each using Horner's method[^horner]:

{% highlight c %}
const float S[] = { 0x1.921fb6p1f, -0x1.4abbecp2f,  0x1.466b2p1f, -0x1.2f5992p-1f };
const float C[] = {-0x1.3bd3ccp2f,  0x1.03c1b8p2f, -0x1.55b7cep0f, 0x1.d684aap-3f };

a2 = a*a;
c  = fmaf(C[3], a2, C[2]); s = fmaf(S[3], a2, S[2]);
c  = fmaf(c,    a2, C[1]); s = fmaf(s,    a2, S[1]);
c  = fmaf(c,    a2, C[0]); s = fmaf(s,    a2, S[0]);
c  = fmaf(c,    a2,  1.f); s = a*s;
{% endhighlight %}

\\
If we test the output of cosine we'd find 94.9% to be correctly rounded[^correct] and the rest are faithfully rounded (target met). Notice that the coefficient table doesn't include constant term. This is so we can simply comment out the final FMA and replace the $8^{\text{th}}$ with the $6^{\text{th}}$ order polynomial coefficients as follows:


{% highlight c %}
//const float C[] = {-0x1.3bd3ccp2f,  0x1.03c1b8p2f, -0x1.55b7cep0f, 0x1.d684aap-3f };
const float C[] = {0x1.fffffep-1f, -0x1.3bd37ep2f, 0x1.03acccp2f, -0x1.4dfd3ap0f};

// all the other terms as above
/*c  = fmaf(c,    a2,  1.f);*/ s = a*s;
{% endhighlight %}

\\
In that case we get 63.2% correctly rounded and rest faithfully. Although with this choice we significantly increase our average and RMS errors we'd still be meeting our target error bound (maximum error)..which is arguably only really interesting one. Moving on to the sine approximation we'd get 73.4692% correctly, 26.5289% faithfully and (sigh) 0.00183582% within 2 ULP. We have a polynomial that can meet our error bound but how we're computing it isn't sufficient. As a polynomial expression (written as evaluated) we currently have:


$$ a (s_0 + \underbrace{a^2 (s_1 + a^2 (s_2 + a^2 s_3))}_{\text{tail}}) $$

\\
Let's plot these values:

{: .center }
<div id="fig2" style="width:100%"></div>


\\
Now let's look at what happens if we rewrite the computation by distributing the outer $a$:


$$ \sin\left(\pi~a\right) \approx \underbrace{a~s_0}_{\text{head}} + \underbrace{a^3 (s_1 + a^2 (s_2 + a^2 s_3))}_{\text{tail}} $$


{: .center }
<div id="fig1" style="width:100%"></div>

\\
and the updated code looks like:


{% highlight c %}
a2 = a*a; 
c  = fmaf(C[3], a2, C[2]); s = fmaf(S[3], a2, S[2]); a3 = a2*a;
c  = fmaf(c,    a2, C[1]); s = fmaf(s,    a2, S[1]);
c  = fmaf(c,    a2, C[0]); s = a3 * s;
c  = fmaf(c,    a2,  1.f); s = fmaf(a,    S[0], s);
{% endhighlight %}

\\
So we're adding an operation (computing $a^3$) but it can be computed in parallel. With this change we get 85.95% correctly and the remaining faithfully rounded. Let's spitball this. In the original expression the 'tail' is being added to $s_0$ (where $s_0 \approx \pi$) in the C expression: `fmaf(s, a2, S[0])` and $s_0$ is significantly larger than the magnitude of *'tail'*. The reworked form computes its subexpression marked *'tail'* and rounds, then the final *FMA* computes *'head'* $({a~s_0})$ and adds its *'tail'* in a single rounding step.

<br>

------

Range reduction
------

\\
Our chosen primary range handles the quarter of the unit circle centered around $a=0$. We now need the code to narrow to our target range on the front end and handle the reverse mappings at the end. 

{% highlight c %}
  r = nearbyintf(a+a);
  a = fmaf(r,-.5f,a);
  q = (uint32_t)((int32_t)r);
{% endhighlight %}

<br>

<div class="alert alert-info" role="alert" markdown="1">
**WARNING:** As written the computation of $q$ is undefined behavior (UB) if $r$ can't be represented as a 32-bit signed integer (in C/C++ land, otherwise check your spec). The issue here is if input ends up a compile time constant which cannot be represented then the compiler can nuke the computation. [example](https://gcc.godbolt.org/z/1csWM97cK). So for this be usable we need to ensure $\left|a\right| \le 2^{30}$. More later.
</div>

\\
Note the use of *FMA* to produce the reduced $a$ isn't needed for accuracy (the result is exact computed with or without) and is being used in case the language and/or compiler disallows promoting (and I'm assuming that an explicit FMA is faster than a multiply add sequence). Now that we have the input factored into reduced $a$ and $q$ we can write the reconstruction as:

$$ \cos\left(\pi~a + \pi \frac{q}{2}\right)$$

\\
and likewise for sin. From the period we can see we only need to bottom two bits of $q$ and from the phase shift identities[^reduce] we get:


{% highlight c %}
  if (q & 2) { s = -s; c = -c; }
  if (q & 1) { t = -s; s =  c;  c = t; }
{% endhighlight %}

\\
To nuke these branches let's define some helper functions:

{% highlight c %}
inline uint32_t f32_to_bits(float x)   { uint32_t u; memcpy(&u,&x,4); return u; }
inline float f32_from_bits(uint32_t x) { float u;    memcpy(&u,&x,4); return u; }

inline float f32_mulsign(float v, uint32_t s) { return f32_from_bits(f32_to_bits(v)^s); }
{% endhighlight %}

\\
The first two simply let us move the floating point bits to an integer and back again. The last simply XORs the two inputs where the intended usage is to pass in a float as the first parameter and the second an integer which is either zero or only has the top bit set. This allows us to multiply by either 1 (integer is zero) or by -1 (only top bit set). So we can eliminate the sign flip portions with:

{% highlight c %}
  uint32_t sy = (q << 31);
  uint32_t sx = (q >>  1) << 31;
  sy ^= sx;
  
  // core approximation here
  s = f32_mulsign(s,sy); c = f32_mulsign(c,sx);

  if (q & 1) { float t = s; s = c; c = t; }
{% endhighlight %}

\\
Now all that's left is swapping the values. For a SIMD version we have to use a branch-free select method, here I'm going to punt and have the function pass in an array pointer and write out the final cosine and sine values to the first and second elements respectively:

{% highlight c %}
  q &= 1;
  // ....
  dst[q  ] = c;
  dst[q^1] = s;
{% endhighlight %}


<br>

------

Paste the parts together
------

\\
Let's take a look at all the parts put together:

{% highlight c %}
// constants for sin(pi x) and cos(pi x) for x on [-1/4,1/4]
const float f32_sinpi_7_k[] = { 0x1.921fb6p1f, -0x1.4abbecp2f,  0x1.466b2p1f, -0x1.2f5992p-1f };
const float f32_cospi_8_k[] = {-0x1.3bd3ccp2f,  0x1.03c1b8p2f, -0x1.55b7cep0f, 0x1.d684aap-3f };


// dst[0] = cos(pi a), dst[1] = sin(pi a)
void f32_sincospi(float* dst, float a)
{
  static const float* S = f32_sinpi_7_k;
  static const float* C = f32_cospi_8_k;

  float    c,s,a2,a3,r;
  uint32_t q,sx,sy;

  // range reduce
  r  = nearbyintf(a+a);
  a  = fmaf(r,-0.5f,a);
  
  // setting up for reconstruct
  q  = (uint32_t)((int32_t)r);
  sy = (q<<31); sx = (q>>1)<<31; sy ^= sx; q &= 1; 
  
  // compute the approximations
  a2 = a*a;
  c  = fmaf(C[3], a2, C[2]); s = fmaf(S[3], a2, S[2]); a3 = a2*a;
  c  = fmaf(c,    a2, C[1]); s = fmaf(s,    a2, S[1]); 
  c  = fmaf(c,    a2, C[0]); s = a3 * s;
  c  = fmaf(c,    a2,  1.f); s = fmaf(a,    S[0], s);
  c  = f32_mulsign(c,sx);    s = f32_mulsign(s,sy);

  dst[q  ] = c;
  dst[q^1] = s;
}
{% endhighlight %}

\\
There's still some minor inefficiencies I'm not going to bother to remove. The most obvious is we can fold the two `f32_mulsign` computations into the core approximations and the rest is "I'm desperate so let's think about the ISA and uArch and look at what the compiler's spitting out". For the former after we've computed `a2` we could do `a = f32_mulsign(a,sy)` which covers adding that sign to `a3` and we're done of the core sign of sine. For cosine we'd need to add its sign `sx` to the one and to a copy of `a2` for the final FMA. 

Note that I've kept the cosine computation as the $8^{\text{th}}$-order polynomial. Dropping a term is a much bigger win then the stuff in the previous paragraph (and recall we're still faithfully rounded). A cut-n-paste version for ya:

<div class="alert alert-info" role="alert" markdown="1">
**WARNING:** An important consideration here is that the 6<sup>th</sup> degree cos approximation never returns 1. You get 1-ulp(1) instead.
</div>

{% highlight c %}
// constants for sin(pi x) and cos(pi x) for x on [-1/4,1/4]
const float f32_sinpi_7_k[] = { 0x1.921fb6p1f,  -0x1.4abbecp2f, 0x1.466b2p1f,  -0x1.2f5992p-1f };
const float f32_cospi_6_k[] = { 0x1.fffffep-1f, -0x1.3bd37ep2f, 0x1.03acccp2f, -0x1.4dfd3ap0f  };

void f32_sincospi(float* dst, float a)
{
  static const float* S = f32_sinpi_7_k;
  static const float* C = f32_cospi_6_k;

  float    c,s,a2,a3,r;
  uint32_t q,sx,sy;

  r  = nearbyintf(a+a);
  a  = fmaf(r,-0.5f,a);
  q  = (uint32_t)((int32_t)r);
  a2 = a*a;
  sy = (q<<31); sx = (q>>1)<<31; sy ^= sx; q &= 1; 
  
  c  = fmaf(C[3], a2, C[2]); s = fmaf(S[3], a2, S[2]); a3 = a2*a;
  c  = fmaf(c,    a2, C[1]); s = fmaf(s,    a2, S[1]); 
  c  = fmaf(c,    a2, C[0]); s = a3 * s;
  c  = f32_mulsign(c,sx);    s = fmaf(a,    S[0], s);
                             s = f32_mulsign(s,sy);

  dst[q  ] = c;
  dst[q^1] = s;
}
{% endhighlight %}

<br>

------

Improved sinpi kernel <small> added: 20221031</small>
------

\\
At the cost of an additional constant load we can rework the *sinpi* approximation to have a much lower average error and transform the majority of *faithfully rounded* outputs to *correctly rounded*. In the original version we reworked the polynomial evaluation to better incorporate the small tail portion. In this updated version we'll instead represent the leading coefficent $s_0$ in extended precision.

The following sollya statement produces a new approximating polynomial:


          S = fpminimax(sin(pi*x), [|1,3,5,7|],   [|48,24...|], [0;1/4], floating, relative);

the only change is adding the '48' to the list of the number of precision bits per coefficient. Recall single precision can represent 24-bits in the normal range and our extended version is twice that (so double precision would be: 106 and 53).

We also need to be able to multiply by our new $s_0$ which is covered in another [post](https://marc-b-reynolds.github.io/math/2020/01/09/ConstAddMul.html) which also covers some more details.  The updated core approximation then looks like (K is the extended precision coefficient and C the remaining):


{% highlight c %}
// sin(pi*a) on [-1/4,1/4]
float f32_sinpi_k7a(float a)
{
  const float      C[] = {-0x1.4abbbap2f, 0x1.465edcp1f, -0x1.2d9e5ap-1f};
  const f32_pair_t K   = {.h = 0x1.921fb6p1f, .l=-0x1.9e5ee4p-24f};
  
  float s,r;
  
  s = a*a;
  r = fmaf(s, C[2],C[1]);
  r = fmaf(s,   r, C[0]);
  r = fmaf(a, K.h, a*fmaf(s,r, K.l));

  return r;
}
{% endhighlight %}


\\
Here are the number of faithfully instead of correctly rounded results on $\left[0,\frac{1}{4}\right]$ for each kernel:

{: .center }
| core          | denormal |  normal  | other  |
| ---:          | ---:     |  ---:    | ---:   |
| f32_cospi_k6  |  n/a     |1029659223| 3085346|
| f32_cospi_k8  |  n/a     |   1015279|  428668|
| f32_sinpi_k7  |  311624  | 342485931| 1179023|
| f32_sinpi_k7a |  311624  |  37382902|  252983|

\\
where the *denormal* is limited to range of correctly rounded denormal results (so only applies to sinpi), *normal* for the remaining and *other* are the counts that will contribute to the other function (so cospi for sinpi entries and vice versa) via range reduction.

The total number of inputs on $\left[0,\frac{1}{2}\right]$ is 1056964608 so for the pair `f32_cospi_k8` and `f32_sinpi_k7a` we can compute the percentage of faithfully rounded for cospi/sinpi by:

$$ \begin{align*}
100 (1015279 + 252983)/1056964608           & \approx 0.119991\% \\
100 (311624 + 37382902 + 428668)/1056964608 & \approx 3.606860\%
\end{align*} $$ 

and these are valid for input on the range $\left[-1,1\right]$. These numbers improve as we grow the range since we have less input precision (one less bit each time we move up a power of two boundary). But anyway this is the really interesting range IMHO.


<br>

------

Less of an eye-sore and other stuff <small> added: 20221031</small>
------

\\
For better or worse the original code above is attempting to visually spitball the instruction level parallelism possible in the computations. Let's just repeat the original cores as individual functions.


<div class="container">
  <div class="row">
    <div class="col-sm">
	
{% highlight c %}
// cos(pi*a) on [-1/4,1/4]
float f32_cospi_k8(float a)
{
  static const float* C = f32_cospi_8_k;

  float r,s;

  s = a*a;
  r = fmaf(C[3], s, C[2]);
  r = fmaf(r,    s, C[1]);
  r = fmaf(r,    s, C[0]);
  r = fmaf(r,    s,  1.f);

  return r;
}
{% endhighlight %}

    </div>
    <div class="col-sm">

{% highlight c %}
// sin(pi*a) on [-1/4,1/4]
float f32_sinpi_k7(float a)
{
  static const float* C = f32_sinpi_7_k;

  float r,a2,a3;

  a2 = a*a; a3 = a2*a;
  r = fmaf(C[3], a2, C[2]);
  r = fmaf(r,    a2, C[1]); 
  r = a3 * r;
  r = fmaf(C[0], a,  r);

  return r;
}
{% endhighlight %}

    </div>
  </div>
</div>


\\
and the original[^disclaimer] front-end range reduction:


{% highlight c %}

// compile time valid provided: |a| <= 0x1.fffffep29 otherwise BOOM!
// runtime pins to infinity:    |a| >= 2^127  which yields: -sign(a)*inf
float f32_pi_func_reduce(float a, uint32_t* q)
{
  float r = nearbyintf(a+a);     // <-- spurious overflow here when |a| >=2^127
  float t = fmaf(-0.5f, r, a);
  
  *q = (uint32_t)((int32_t)r);   // <-- recall UB here if overflows
  
  return t;
}
{% endhighlight %}

\\
As previously mentioned there's some limitations with this reduction (see code comments). I'm leaving this in place because I think it's a useful version for my intended target audience where almost all calls will be on $\left[-1,1\right]$ and still works up to $\left\| a \right\| \lt 2^{30}$. However I'll toss out a modification to handle the UB case as well.

But first there is a compliant range reduction in Norbert Juffa's `sincospi` (& w/o direct bit manipulation) which written up on [StackOverflow](https://stackoverflow.com/a/42792940). Let's take a look the front-end part of his reduction:

{% highlight c %}
  // for |a| > 2**24, cospi(a) = 1.0f, but cospi(Inf) = NaN
  az = a * 0.0f;                         // must be evaluated with IEEE-754 semantics
  a = (fabsf (a) < 0x1.0p24f) ? a : az;  // <-- comment is for here
  r = nearbyintf (a + a);                // must use IEEE-754 "to nearest" rounding
  i = (int32_t)r;
  t = fmaf (-0.5f, r, a);
{% endhighlight %}

\\
OK: so `az` is just the zero with the same sign as `a`, then he limits `a` in the denoted line. In addition to preventing both UB in the cast and the spurious overflow in the `nearbyint` call it also prevents the overflow stick bit/flag (as per so-called floating point exceptions) from being set by `nearbyint`. 

What I'd prefer to avoid (for a non-standard version) is the extra latency introduced limiting `a` before computing `r` which is needed to start the polynomial evaluations and just remove the UB:


{% highlight c %}

// runtime pins to infinity if |a| >= 2^127  which yields: -sign(a)*inf
float f32_pi_func_reduce(float a, uint32_t* q)
{
  float r = nearbyintf(a+a);
  float t = fmaf(-0.5f, r, a);
  
  *q = (fabs(f) < 0x1.0p24f) ? (uint32_t)((int32_t)r) : 0;
//*q = (r*r     < 0x1.0p25f) ? (uint32_t)((int32_t)r) : 0;
  
  return t;
}
{% endhighlight %}

\\
the commented out statement is a possible alternate (ARM has fabs, Intel has to mask off bit). So anyway: a slightly less ugly version:

{% highlight c %}
void f32_sincospi(float* dst, float a)
{
  uint32_t q,sx,sy;
  
  a = f32_pi_func_reduce(a, &q);

  // whatever choice of core approximations
  float c = f32_cospi_k8(a);
  float s = f32_sinpi_k7a(a);

  // or however you want the handle the reconstruction
  sy = (q<<31); sx = (q>>1)<<31; sy ^= sx; q &= 1; 
  c  = f32_mulsign(c,sx);
  s  = f32_mulsign(s,sy);

  dst[q  ] = c;
  dst[q^1] = s;
}
{% endhighlight %}




<br>

------

Tau <small>or full turn</small>
------

\\
Since recently there's seemingly been an interest spike in $\tau$ or "full turn" variants (perhaps from Casey Muratori's [tweet](https://twitter.com/cmuratori/status/1574311250838061056)) we might as well cover that case as well:

{% highlight c %}
inline void f32_sincos_tau(float* dst, float a) { f32_sincospi(dst, 2.f*a); }
{% endhighlight %}

\\
provided your language and compiler are mildly aggressive with inlining then this is "free" otherwise tweaking the statement (or equivalent) `nearbyintf(a+a)` to `nearbyintf(4.f*a)` in the range reduction and you're done. Well other than documenting valid ranges given the choice of range reduction implementation. (notice no rounding errors are introduced by this modification)



<br>

------

Sollya output summary
------

\\
This section summarizes the output of the sollya script giving the supnorm and coefficents of various degree approximations for both single and double precision. The full output also include tables of inputs where each has zero and maximum errors on the primary range.

**single precision sine:**

{: .center }
| degree | supnorm        |  supnorm   |
| ---:   | ---:           |  ---:      |
| 3      | $\text{0x1.2ed540} \cdot 2^{-12}$ |  $ \approx 2.8880 \cdot 10^{-4} $ |
| 5      | $\text{0x1.1ea062} \cdot 2^{-20}$ |  $ \approx 1.0678 \cdot 10^{-6} $ |
| 7      | $\text{0x1.71dde6} \cdot 2^{-28}$ |  $ \approx 5.3824 \cdot 10^{-9} $ |

<br>

{% highlight c %}
float f32_sin_pi_3_k = {0x1.91f5aap1f, -0x1.408cf2p2f};
float f32_sin_pi_5_k = {0x1.921f8ep1f, -0x1.4aa618p2f, 0x1.3f3f3cp1f};
float f32_sin_pi_7_k = {0x1.921fb6p1f, -0x1.4abbecp2f, 0x1.466b2p1f, -0x1.2f5992p-1f};
{% endhighlight %}

\\
**single precision cosine:**

{: .center }
| degree | supnorm        |  supnorm   |
| ---:   | ---:           |  ---:      |
| 4      | $\text{0x1.8c    } \cdot 2^{-17}$ |  $ \approx 1.1802\cdot 10^{-5} $ |
| 6      | $\text{0x1.0     } \cdot 2^{-24}$ |  $ \approx 5.9605\cdot 10^{-8} $ |
| 8      | $\text{0x1.1093e2} \cdot 2^{-31}$ |  $ \approx 4.9582\cdot 10^{-10} $ |

<br>

{% highlight c %}
float f32_cos_pi_4_k = {0x1.fffe74p-1f, -0x1.3ba0ecp2f, 0x1.f73ff8p1f};
float f32_cos_pi_6_k = {0x1.fffffep-1f, -0x1.3bd37ep2f, 0x1.03acccp2f, -0x1.4dfd3ap0f};
float f32_cos_pi_8_k = {0x1p0.0f, -0x1.3bd3ccp2f, 0x1.03c1b8p2f, -0x1.55b7cep0f, 0x1.d684aap-3f};
{% endhighlight %}


\\
**double precision sine:**

{: .center }
| degree | supnorm        |  supnorm   |
| ---:   | ---:           |  ---:      |
|  7     | $\text{0x1.3ab388049b2fb} \cdot 2^{-29}$ |  $ \approx 2.2898\cdot 10^{-9} $ |
|  9     | $\text{0x1.c4c3c95e213b2} \cdot 2^{-39}$ |  $ \approx 3.2171\cdot 10^{-12} $ |
| 11     | $\text{0x1.ca8315e19366f} \cdot 2^{-49}$ |  $ \approx 3.1816\cdot 10^{-15} $ |
| 13     | $\text{0x1.3ebb2d89a070c} \cdot 2^{-59}$ |  $ \approx 2.1598\cdot 10^{-18} $ |

<br>

{% highlight c %}
double f64_sin_pi_7_k  = {0x1.921fb52e6a183p1, -0x1.4abbb9003982p2, 0x1.465e91ee1939cp1, -0x1.2d93021f38404p-1};
double f64_sin_pi_9_k  = {0x1.921fb5443af5fp1, -0x1.4abbce564cd85p2, 0x1.466bba8bfcp1, -0x1.32ca854cad10ep-1, 0x1.4bc25574ce357p-4};
double f64_sin_pi_11_k = {0x1.921fb54442cf8p1, -0x1.4abbce6257778p2, 0x1.466bc670fa464p1, -0x1.32d2c627f47dap-1, 0x1.5071be0a2d3dap-4, -0x1.dd4e0ae5b9fcdp-8};
double f64_sin_pi_13_k = {0x1.921fb54442d18p1, -0x1.4abbce625be09p2, 0x1.466bc67754fffp1, -0x1.32d2ccdfe9424p-1, 0x1.50782d5f14825p-4, -0x1.e2fe76fdffd2bp-8, 0x1.e357ef99eb0bbp-12};
{% endhighlight %}

\\
**double precision cosine:**

{: .center }
| degree | supnorm        |  supnorm   |
| ---:   | ---:           |  ---:      |
| 6      | $\text{0x1.18263bb      } \cdot 2^{-25}$ |  $ \approx 3.2614 \cdot 10^{-8}  $ |
| 8      | $\text{0x1.ed22         } \cdot 2^{-35}$ |  $ \approx 5.6063 \cdot 10^{-11} $ |
| 10     | $\text{0x1.278          } \cdot 2^{-44}$ |  $ \approx 6.5614 \cdot 10^{-14} $ |
| 12     | $\text{0x1.0            } \cdot 2^{-53}$ |  $ \approx 1.1102 \cdot 10^{-16} $ |
| 14     | $\text{0x1.c8900a3e39182} \cdot 2^{-62}$ |  $ \approx 3.8672 \cdot 10^{-19} $ |

<br>

{% highlight c %}
double f64_cos_pi_6_k  = {0x1.fffffee7d9c45p-1, -0x1.3bd38b6200606p2, 0x1.03ae64c9b1678p2, -0x1.4e35da5eabfc3p0};
double f64_cos_pi_8_k  = {0x1.ffffffff84b78p-1, -0x1.3bd3cc6e7cf9dp2, 0x1.03c1daad03632p2, -0x1.55c4e9c28184p0, 0x1.d99f538fa683dp-3};
double f64_cos_pi_10_k = {0x1.ffffffffffdb1p-1, -0x1.3bd3cc9bd0994p2, 0x1.03c1f073cd5eap2, -0x1.55d3b9726d2d5p0, 0x1.e1e761359aeb5p-3, -0x1.a0d8acfd174acp-6};
double f64_cos_pi_12_k = {0x1.fffffffffffffp-1, -0x1.3bd3cc9be4565p2, 0x1.03c1f081af262p2, -0x1.55d3c7dac6352p0, 0x1.e1f4fa4f3bb22p-3, -0x1.a6c9501cb8cdap-6, 0x1.f3b7b6aafa2abp-10};
double f64_cos_pi_14_k = {0x1p0.0, -0x1.3bd3cc9be45dep2, 0x1.03c1f081b5a67p2, -0x1.55d3c7e3c325bp0, 0x1.e1f5067b90b37p-3, -0x1.a6d1e7294bffap-6, 0x1.f9c89ca1d5187p-10, -0x1.b167302e37198p-14};
{% endhighlight %}

<br>

------

References and footnotes
------

[^rgreen]: **"Faster math function"**, Robin Green [(link)](https://basesandframes.wordpress.com/2016/05/17/faster-math-functions/)
[^sollya]: **"Sollya: an environment for the development of numerical codes"**, [(project page)](http://sollya.gforge.inria.fr/)
[^horner]: **"Horner's method"** [(Wikipedia)](https://en.wikipedia.org/wiki/Horner%27s_method)
[^estrin]: **"Estrin's scheme"** [(Wikipedia)](https://en.wikipedia.org/wiki/Estrin%27s_scheme)
[^fma]:    **"Fused multiply accumulate"** [(Wikipedia)](https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation#Fused_multiply-add)
[^reduce]: **"List of trigonometric identities"** [(Wikipedia)](https://en.wikipedia.org/wiki/List_of_trigonometric_identities#Shifts_and_periodicity)
[^correct]: Correctly rounded: the floating point result is the nearest one to the exact (the error is less that 1/2 ULP).
[^CGPE]:   **"CGPE: Code Generation for Polynomial Evaluation"** [(project page)](http://cgpe.gforge.inria.fr/index.php?page=home)
[^disclaimer]: Actually there's a couple of modification here as well. I was originally using `rintf` which rounds according to the currently set rounding mode. This has been changed to using `nearbyintf`. On Intel and ARM this switch is free as both support in hardware. The second change was the original cast of `q` was directly to `uint32_t` instead of through `int32_t` first. Again on Intel and ARM this is free.

<br>

<script>

const plot0 = {
x:[5.10204e-9, 0.0000766795, 0.000153354, 0.000306703, 0.0006134, 0.0012268, 0.00245359, 0.00490717, 0.0102271, 0.0151945, 0.0200644, 0.0253471, 0.0302773, 0.0356202, 0.0408657, 0.0457586, 0.0510643, 0.0560175, 0.0608732, 0.0661417, 0.0710577, 0.0763864, 0.0816176, 0.0864964, 0.0917879, 0.0967268, 0.102079, 0.107333, 0.112235, 0.117549, 0.122511, 0.127375, 0.132653, 0.137577, 0.142915, 0.148155, 0.153043, 0.158343, 0.163291, 0.168141, 0.173404, 0.178314, 0.183638, 0.188608, 0.193482, 0.198768, 0.203701, 0.209048, 0.214296, 0.219193, 0.224502, 0.229458, 0.234317, 0.239589, 0.244509, 0.244594, 0.24468, 0.244852, 0.245195, 0.245881, 0.247254, 0.24734, 0.247426, 0.247597, 0.247941, 0.248627, 0.248713, 0.248799, 0.24897, 0.249314, 0.249399, 0.249485, 0.249657, 0.249743, 0.249828, 0.249914, 0.25],
y:[1.60285e-8, 0.000240896, 0.000481775, 0.000963535, 0.00192705, 0.00385408, 0.00770809, 0.0154157, 0.0321238, 0.0477167, 0.0629925, 0.0795462, 0.0949755, 0.111671, 0.128031, 0.14326, 0.159736, 0.175077, 0.190075, 0.206298, 0.221385, 0.237678, 0.253609, 0.268405, 0.28438, 0.299221, 0.315221, 0.330842, 0.345334, 0.360954, 0.375448, 0.389567, 0.404782, 0.418881, 0.434047, 0.448819, 0.462486, 0.477185, 0.490787, 0.504005, 0.518217, 0.531348, 0.545441, 0.558462, 0.571096, 0.584649, 0.597153, 0.61054, 0.623516, 0.635468, 0.648257, 0.660034, 0.671425, 0.683606, 0.694803, 0.694997, 0.695191, 0.695578, 0.696353, 0.697899, 0.700981, 0.701173, 0.701365, 0.70175, 0.702517, 0.70405, 0.704242, 0.704433, 0.704816, 0.70558, 0.705771, 0.705962, 0.706344, 0.706535, 0.706725, 0.706916, 0.707107],
mode: 'lines',
name: 'sin(&#x03C0; a)'
};

const plot1 = {
x:[5.10204e-9, 0.0000766795, 0.000153354, 0.000230028, 0.000306703, 0.000383377, 0.000460051, 0.000536726, 0.0006134, 0.000690075, 0.000766749, 0.000843423, 0.000920098, 0.000996772, 0.00107345, 0.00115012, 0.0012268, 0.00130347, 0.00138014, 0.00145682, 0.00153349, 0.00161017, 0.00168684, 0.00176352, 0.00184019, 0.00191686, 0.00199354, 0.00207021, 0.00214689, 0.00222356, 0.00230024, 0.00245359, 0.00253026, 0.00260693, 0.00276028, 0.00283696, 0.00291363, 0.00306698, 0.00314365, 0.00322033, 0.00337368, 0.00345035, 0.00352703, 0.00368038, 0.00375705, 0.00383372, 0.00398707, 0.00406375, 0.00414042, 0.00429377, 0.00437044, 0.00444712, 0.00460047, 0.00490717, 0.00499029, 0.00507341, 0.00523966, 0.00532278, 0.00540591, 0.00557216, 0.00565528, 0.0057384, 0.00590465, 0.00623715, 0.00632027, 0.00640339, 0.00656964, 0.00690214, 0.00698526, 0.00706838, 0.00723463, 0.00756713, 0.00765025, 0.00773337, 0.00789962, 0.00823212, 0.00831524, 0.00839837, 0.00856461, 0.00889711, 0.00898023, 0.00906336, 0.0092296, 0.0095621, 0.0102271, 0.0103047, 0.0103823, 0.0105376, 0.010848, 0.0114689, 0.0115466, 0.0116242, 0.0117794, 0.0120899, 0.0127108, 0.0127884, 0.012866, 0.0130212, 0.0133317, 0.0139526, 0.0140302, 0.0141079, 0.0142631, 0.0145735, 0.0151945, 0.0152706, 0.0153467, 0.0154988, 0.0158032, 0.016412, 0.016488, 0.0165641, 0.0167163, 0.0170207, 0.0176294, 0.0177055, 0.0177816, 0.0179338, 0.0182382, 0.0188469, 0.0200644, 0.020147, 0.0202295, 0.0203946, 0.0207248, 0.0213851, 0.0227058, 0.0227883, 0.0228708, 0.0230359, 0.0233661, 0.0240264, 0.0253471, 0.0254242, 0.0255012, 0.0256553, 0.0259634, 0.0265797, 0.0278122, 0.0278892, 0.0279663, 0.0281203, 0.0284285, 0.0290447, 0.0302773, 0.0303608, 0.0304442, 0.0306112, 0.0309451, 0.031613, 0.0329487, 0.0330322, 0.0331157, 0.0332827, 0.0336166, 0.0342845, 0.0356202, 0.0357022, 0.0357841, 0.035948, 0.0362759, 0.0369316, 0.0382429, 0.0383249, 0.0384069, 0.0385708, 0.0388986, 0.0395543, 0.0408657, 0.0409421, 0.0410186, 0.0411715, 0.0414773, 0.0420889, 0.0433122, 0.0457586, 0.0458415, 0.0459244, 0.0460902, 0.0464219, 0.0470851, 0.0484115, 0.0510643, 0.0511417, 0.0512191, 0.0513739, 0.0516835, 0.0523026, 0.0535409, 0.0560175, 0.0608732, 0.0661417, 0.0710577, 0.0763864, 0.0816176, 0.0864964, 0.0917879, 0.0967268, 0.102079, 0.107333, 0.112235, 0.117549, 0.122511, 0.127375, 0.132653, 0.137577, 0.142915, 0.148155, 0.153043, 0.158343, 0.163291, 0.168141, 0.173404, 0.178314, 0.183638, 0.188608, 0.193482, 0.198768, 0.203701, 0.209048, 0.214296, 0.219193, 0.224502, 0.229458, 0.234317, 0.239589, 0.244509, 0.244594, 0.24468, 0.244852, 0.245195, 0.245881, 0.247254, 0.24734, 0.247426, 0.247597, 0.247941, 0.248627, 0.248713, 0.248799, 0.24897, 0.249314, 0.249399, 0.249485, 0.249657, 0.249743, 0.249828, 0.249914, 0.25],
y:[-6.86326e-25, -2.3299e-12, -1.86373e-11, -6.28988e-11, -1.49091e-10, -2.9119e-10, -5.03174e-10, -7.99017e-10, -1.1927e-9, -1.69819e-9, -2.32948e-9, -3.10053e-9, -4.02532e-9, -5.11783e-9, -6.39204e-9, -7.86193e-9, -9.54146e-9, -1.14446e-8, -1.35854e-8, -1.59777e-8, -1.86356e-8, -2.1573e-8, -2.4804e-8, -2.83424e-8, -3.22023e-8, -3.63976e-8, -4.09423e-8, -4.58504e-8, -5.11359e-8, -5.68127e-8, -6.28949e-8, -7.6331e-8, -8.3713e-8, -9.15562e-8, -1.08682e-7, -1.17993e-7, -1.27821e-7, -1.49084e-7, -1.60547e-7, -1.72583e-7, -1.9843e-7, -2.12269e-7, -2.26737e-7, -2.57616e-7, -2.74054e-7, -2.91178e-7, -3.27535e-7, -3.46797e-7, -3.668e-7, -4.09083e-7, -4.31392e-7, -4.54497e-7, -5.03153e-7, -6.10641e-7, -6.42201e-7, -6.7483e-7, -7.43366e-7, -7.79309e-7, -8.16392e-7, -8.94051e-7, -9.34661e-7, -9.76484e-7, -1.06383e-6, -1.25386e-6, -1.30466e-6, -1.35682e-6, -1.46526e-6, -1.69918e-6, -1.76131e-6, -1.82494e-6, -1.95676e-6, -2.23913e-6, -2.31373e-6, -2.38997e-6, -2.54744e-6, -2.88283e-6, -2.97104e-6, -3.06103e-6, -3.24643e-6, -3.63939e-6, -3.74235e-6, -3.84723e-6, -4.06284e-6, -4.51793e-6, -5.52755e-6, -5.65435e-6, -5.78308e-6, -6.04636e-6, -6.59666e-6, -7.79543e-6, -7.95476e-6, -8.11625e-6, -8.44575e-6, -9.13127e-6, -0.0000106116, -0.0000108072, -0.0000110051, -0.0000114083, -0.0000122438, -0.0000140354, -0.0000142709, -0.0000145091, -0.0000149933, -0.0000159937, -0.0000181262, -0.0000183998, -0.0000186763, -0.0000192374, -0.000020393, -0.0000228414, -0.0000231605, -0.0000234826, -0.0000241358, -0.0000254782, -0.0000283105, -0.0000286787, -0.00002905, -0.0000298022, -0.0000313453, -0.0000345895, -0.0000417342, -0.0000422513, -0.0000427727, -0.0000438283, -0.0000459912, -0.0000505282, -0.0000604779, -0.0000611398, -0.0000618064, -0.0000631543, -0.0000659084, -0.0000716545, -0.0000841292, -0.0000848985, -0.0000856723, -0.0000872342, -0.0000904146, -0.0000970054, -0.000111132, -0.000112058, -0.000112989, -0.000114866, -0.000118682, -0.000126567, -0.000143368, -0.000144557, -0.000145752, -0.000148163, -0.000153063, -0.000163186, -0.000184749, -0.000186157, -0.000187571, -0.000190422, -0.000196209, -0.000208132, -0.000233408, -0.000235023, -0.000236644, -0.00023991, -0.000246531, -0.000260136, -0.000288828, -0.000290688, -0.000292556, -0.000296316, -0.000303933, -0.000319555, -0.000352385, -0.000354366, -0.000356353, -0.000360351, -0.000368436, -0.000384966, -0.000419495, -0.000494617, -0.000497309, -0.00050001, -0.000505441, -0.000516422, -0.000538857, -0.000585655, -0.000687216, -0.000690343, -0.000693479, -0.00069978, -0.000712495, -0.000738386, -0.000792031, -0.00090698, -0.00116355, -0.00149207, -0.00184948, -0.00229666, -0.00280042, -0.00333188, -0.00397969, -0.00465516, -0.00546851, -0.0063537, -0.0072607, -0.0083367, -0.00943206, -0.0105945, -0.0119585, -0.0133316, -0.0149332, -0.0166243, -0.0183111, -0.0202637, -0.0222058, -0.0242247, -0.0265478, -0.0288431, -0.0314742, -0.0340687, -0.0367445, -0.0397984, -0.042794, -0.0462023, -0.049716, -0.0531465, -0.0570361, -0.0608302, -0.064705, -0.069086, -0.0733431, -0.0734188, -0.0734946, -0.0736463, -0.0739502, -0.0745606, -0.0757912, -0.0758685, -0.0759459, -0.0761008, -0.0764113, -0.0770347, -0.0771129, -0.0771911, -0.0773477, -0.0776614, -0.07774, -0.0778186, -0.077976, -0.0780548, -0.0781336, -0.0782125, -0.0782914],
mode: 'lines',
name: 'tail'
};

const plot2 = {
x:[5.10204e-9, 0.0000766795, 0.000153354, 0.000306703, 0.0006134, 0.0012268, 0.00245359, 0.00490717, 0.0102271, 0.0151945, 0.0200644, 0.0253471, 0.0302773, 0.0356202, 0.0408657, 0.0457586, 0.0510643, 0.0560175, 0.0608732, 0.0661417, 0.0710577, 0.0763864, 0.0816176, 0.0864964, 0.0917879, 0.0967268, 0.102079, 0.107333, 0.112235, 0.117549, 0.122511, 0.127375, 0.132653, 0.137577, 0.142915, 0.148155, 0.153043, 0.158343, 0.163291, 0.168141, 0.173404, 0.178314, 0.183638, 0.188608, 0.193482, 0.198768, 0.203701, 0.209048, 0.214296, 0.219193, 0.224502, 0.229458, 0.234317, 0.239589, 0.244509, 0.244594, 0.24468, 0.244852, 0.245195, 0.245881, 0.247254, 0.24734, 0.247426, 0.247597, 0.247941, 0.248627, 0.248713, 0.248799, 0.24897, 0.249314, 0.249399, 0.249485, 0.249657, 0.249743, 0.249828, 0.249914, 0.25],
y:[1.60285e-8, 0.000240896, 0.000481775, 0.000963535, 0.00192705, 0.00385409, 0.00770817, 0.0154163, 0.0321293, 0.0477348, 0.0630342, 0.0796303, 0.0951189, 0.111904, 0.128383, 0.143755, 0.160423, 0.175984, 0.191239, 0.20779, 0.223234, 0.239975, 0.256409, 0.271736, 0.28836, 0.303876, 0.320689, 0.337196, 0.352595, 0.369291, 0.38488, 0.400162, 0.416741, 0.432212, 0.448981, 0.465443, 0.480797, 0.497449, 0.512992, 0.52823, 0.544765, 0.560191, 0.576915, 0.592531, 0.607841, 0.624448, 0.639947, 0.656742, 0.673232, 0.688614, 0.705293, 0.720865, 0.73613, 0.752692, 0.768146, 0.768416, 0.768685, 0.769225, 0.770303, 0.772459, 0.776772, 0.777042, 0.777311, 0.777851, 0.778929, 0.781085, 0.781355, 0.781624, 0.782163, 0.783242, 0.783511, 0.783781, 0.78432, 0.784589, 0.784859, 0.785129, 0.785398],
mode: 'lines',
name: 'head'
};


const plot3 = {
x:[5.10204e-9, 0.00245359, 0.00490717, 0.0102271, 0.0151945, 0.0200644, 0.0253471, 0.0302773, 0.0356202, 0.0408657, 0.0457586, 0.0510643, 0.0560175, 0.0608732, 0.0661417, 0.0710577, 0.0763864, 0.0816176, 0.0864964, 0.0917879, 0.0967268, 0.102079, 0.107333, 0.112235, 0.117549, 0.122511, 0.127375, 0.132653, 0.137577, 0.142915, 0.148155, 0.153043, 0.158343, 0.163291, 0.168141, 0.173404, 0.178314, 0.183638, 0.188608, 0.193482, 0.198768, 0.203701, 0.209048, 0.214296, 0.219193, 0.224502, 0.229458, 0.234317, 0.239589, 0.244509, 0.247254, 0.25],
y:[3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159, 3.14159],
mode: 'lines',
name: 's<sub>0</sub>'
};

const plot4 = {
x:[5.10204e-9, 0.0000766795, 0.000153354, 0.000230028, 0.000306703, 0.000383377, 0.000460051, 0.000536726, 0.0006134, 0.000690075, 0.000766749, 0.000843423, 0.000920098, 0.000996772, 0.00107345, 0.0012268, 0.00130347, 0.00138014, 0.00153349, 0.00161017, 0.00168684, 0.00184019, 0.00191686, 0.00199354, 0.00214689, 0.00245359, 0.00253026, 0.00260693, 0.00276028, 0.00306698, 0.00314365, 0.00322033, 0.00337368, 0.00368038, 0.00375705, 0.00383372, 0.00398707, 0.00429377, 0.00490717, 0.00499029, 0.00507341, 0.00523966, 0.00557216, 0.00623715, 0.00632027, 0.00640339, 0.00656964, 0.00690214, 0.00756713, 0.00765025, 0.00773337, 0.00789962, 0.00823212, 0.00889711, 0.0102271, 0.0103047, 0.0103823, 0.0105376, 0.010848, 0.0114689, 0.0127108, 0.0127884, 0.012866, 0.0130212, 0.0133317, 0.0139526, 0.0151945, 0.0152706, 0.0153467, 0.0154988, 0.0158032, 0.016412, 0.0176294, 0.0177055, 0.0177816, 0.0179338, 0.0182382, 0.0188469, 0.0200644, 0.020147, 0.0202295, 0.0203946, 0.0207248, 0.0213851, 0.0227058, 0.0253471, 0.0254242, 0.0255012, 0.0256553, 0.0259634, 0.0265797, 0.0278122, 0.0302773, 0.0356202, 0.0408657, 0.0457586, 0.0510643, 0.0560175, 0.0608732, 0.0661417, 0.0710577, 0.0763864, 0.0816176, 0.0864964, 0.0917879, 0.0967268, 0.102079, 0.107333, 0.112235, 0.117549, 0.122511, 0.127375, 0.132653, 0.137577, 0.142915, 0.148155, 0.153043, 0.158343, 0.163291, 0.168141, 0.173404, 0.178314, 0.183638, 0.188608, 0.193482, 0.198768, 0.203701, 0.209048, 0.214296, 0.219193, 0.224502, 0.229458, 0.234317, 0.239589, 0.244509, 0.244594, 0.24468, 0.244852, 0.245195, 0.245881, 0.247254, 0.24734, 0.247426, 0.247597, 0.247941, 0.248627, 0.248713, 0.248799, 0.24897, 0.249314, 0.249399, 0.249485, 0.249657, 0.249743, 0.249828, 0.249914, 0.25],
y:[-1.3452e-16, -3.03849e-8, -1.21531e-7, -2.73439e-7, -4.86109e-7, -7.59541e-7, -1.09373e-6, -1.48869e-6, -1.9444e-6, -2.46088e-6, -3.03812e-6, -3.67612e-6, -4.37488e-6, -5.13441e-6, -5.95469e-6, -7.77755e-6, -8.78012e-6, -9.84345e-6, -0.0000121524, -0.000013398, -0.0000147044, -0.0000174994, -0.0000189881, -0.0000205375, -0.0000238186, -0.00003111, -0.0000330847, -0.0000351202, -0.0000393735, -0.0000486092, -0.0000510701, -0.0000535917, -0.0000588171, -0.0000699971, -0.000072944, -0.0000759517, -0.0000821493, -0.0000952736, -0.000124439, -0.00012869, -0.000133013, -0.000141873, -0.00016045, -0.000201031, -0.000206425, -0.00021189, -0.000223035, -0.000246182, -0.000295903, -0.000302439, -0.000309047, -0.000322477, -0.000350193, -0.000409053, -0.000540481, -0.000548716, -0.000557012, -0.000573792, -0.000608099, -0.000679699, -0.000834851, -0.000845076, -0.000855365, -0.000876128, -0.000918401, -0.00100593, -0.00119295, -0.00120492, -0.00121696, -0.00124121, -0.00129044, -0.00139175, -0.00160587, -0.00161976, -0.00163371, -0.00166179, -0.00171866, -0.00183529, -0.00208001, -0.00209716, -0.00211437, -0.00214901, -0.00221914, -0.00236278, -0.00266355, -0.00331909, -0.00333928, -0.00335954, -0.00340025, -0.00348239, -0.00364961, -0.0039958, -0.00473518, -0.00655269, -0.00862301, -0.0108093, -0.0134578, -0.016191, -0.0191143, -0.0225586, -0.0260279, -0.0300663, -0.0343115, -0.0385204, -0.0433574, -0.0481268, -0.0535716, -0.0591963, -0.0646922, -0.070921, -0.0769895, -0.083175, -0.0901487, -0.0969028, -0.10449, -0.112209, -0.119647, -0.127974, -0.135989, -0.144074, -0.153098, -0.161754, -0.171393, -0.180632, -0.189912, -0.200226, -0.210082, -0.221013, -0.231996, -0.242465, -0.254056, -0.265103, -0.276142, -0.288352, -0.299961, -0.300166, -0.30037, -0.300779, -0.301598, -0.303238, -0.306531, -0.306738, -0.306944, -0.307357, -0.308184, -0.30984, -0.310048, -0.310255, -0.31067, -0.311501, -0.311709, -0.311917, -0.312333, -0.312541, -0.312749, -0.312957, -0.313166],
mode: 'lines',
name: 'tail'
};


const data  = [plot2,plot0,plot1];
const data2 = [plot3,plot4];

const layout = {
  yaxis: { hoverformat: 'g' },
  height: 476,
  width:  826
};

const def = {displaylogo: false, autosizable: false};

Plotly.newPlot('fig1', data,  layout, def);
Plotly.newPlot('fig2', data2, layout, def);

</script>
