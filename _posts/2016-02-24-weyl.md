---
layout: post
title:  Weyl generator overview
tags : [random, low-discrepency, sampling, hashing]
description : a brief overview of Weyl generators
---

Awhile back I ran across the stackoverflow question: *What's the origin of this GLSL rand() one-liner:*

{% highlight c %}
float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
{% endhighlight %}

to which I provided this [guess of an answer](http://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner/34223787#34223787).  Writing that response reminded me of a closely related structure that doesn't seem to be well known, the **Weyl generator**. This post is intended to provide minimal background on this family and I'll presents some techniques based on them later.

<br>

------

The theory <small>or this doesn't really work</small>
------

Weyl generators (or sequences) are named after [Hermann Weyl](http://en.wikipedia.org/wiki/Hermann_Weyl) for the [equidistribution theorem](http://en.wikipedia.org/wiki/Equidistribution_theorem) and Weyl's criterion (SEE: [Normal numbers](http://en.wikipedia.org/wiki/Normal_number) and [equidistributed sequences]((http://en.wikipedia.org/wiki/Equidistributed_sequence))).

One possible way to generate a uniform sequence, where the members are named as follows:

$$ \left\{ s_{0},s_{1},s_{2},s_{3},\cdots\right\} $$

is a polynomial mod 1 that contains at least one irrational coefficient other than the constant term.  For degrees 1 and 2, where $ \alpha $ is an irrational constant, $ n \in \mathbb{N}_0 $ (positive integers including zero):

$$ \begin{equation} \label{eq:rweyl1}
s_{n}=\left(n\thinspace \alpha + \thinspace s_{0}\right)\bmod 1
\end{equation} $$ 

$$ \begin{equation} \label{eq:rweyl2}
s_{n}=\left(n^2\thinspace \alpha + \thinspace s_{0}\right)\bmod 1
\end{equation} $$ 

both produce uniform sequences with $ s_{n} \in \left[0,1\right) $

The so far unspoken trick to the above is that it requires the operations to be performed in reals, as the properties are based on the infinite string of digits (in some base) of irrationals.

<br>

------

The real world <small>without Reals</small>
------
Working in finite math requires some tweaks, let's start with floating point. We really want the low bits of the operations so let's call our *logical* irrational $ k $, then our constant $ \alpha = k \bmod 1 $.  We'll call $ \eqref{eq:rweyl1}  $ a *"Weyl generator"* and its formulation remains the same.

Equation $ \eqref{eq:rweyl1} $ can also be expressed as a recurrence relation (a.k.a. additive recurrance):

$$ \begin{equation} \label{eq:fadditive}
s_{n+1}=\left(s_{n}+\alpha\right)\bmod 1
\end{equation} $$

to state the obvious $ \eqref{eq:rweyl1} $ and $ \eqref{eq:fadditive} $ do not produce the same sequences in floating point. Also the modulo of $ \eqref{eq:fadditive} $ can be removed as it simply subtracts one if it has moved out of the interval (say if you have a fast select).  We need to rework \eqref{eq:rweyl2} and we'll call it a *"nested Weyl"*:

$$ \begin{equation} \label{eq:fweyl2}
s_{n}=n\left(\left(n\thinspace \alpha\right)\bmod 1\right)\bmod 1
\end{equation} $$

<br>

------
The generally better option is to convert to integers by scaling the constant by the bit width being used *and* rounding to odd.  The latter insures that both products and additions are one-to-one mappings.

The $ x \bmod 1 $ operations are mapped to the native integer modulo.

{% highlight c++ %}
static inline uint32_t weyl(uint32_t n)      { return K*n;   }  // (1)
static inline uint32_t weyl_next(uint32_t s) { return K+s;   }  // (.)
{% endhighlight %}




Then a simple Weyl sequence (a.k.a. [equidistribution modulo 1](http://en.wikipedia.org/wiki/Equidistributed_sequence#Equidistribution_modulo_1)), where \\( \alpha \\) is a irrational constant:
<br>

------

I don't believe you <small>without Reals</small>
------



<br>

------

Into the wild <small></small>
------



