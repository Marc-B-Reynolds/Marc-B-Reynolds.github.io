---
layout:       post
title:        Uniform points on disc, circle, sphere and caps
tagline:      
categories:   [distribution]
tags:         [distribution, random]
description:  a brief note on some basic uniform spatial distributions
plotly:       true
---

Here I will only consider pseudo-random point generation.  Well-spaced point generation is a different topic.  The code examples are intended for clarity.

------

Uniform points on the unit disc
------

\\
One method to generate a uniform random point $p$ on the unit disc ($\mathbb{D}$) is as follows.  Generate two uniform values: $a \in \left[ 0,1 \right] $ , $ \theta \in \left[ -\pi, \pi \right) $ and apply[^mwDisc]:

$$ p = \left(\sqrt{a}\cos\left(\theta\right), ~\sqrt{a}\sin\left(\theta\right)\right) $$

\\
Using symmetry and trig identities we can drop this down to one trig approximation and pair of square roots.

<br>

#### Rejection method

Choose a 2D point $p$ uniformly in each dimension: $p_x,p_y \in \left[ -1,1 \right] $ and reject values when outside the unit disc.  The average number of iterations is $\frac{4}{\pi} \approx 1.27324$.  Although previously known the first CS publication of this technique seems to be von Neumann 1951[^jvnCircle].

An example implementation that returns $p \cdot p$ as well as the generated point:

<br>
{% highlight c %}
float uniform_disc(vec2_t* p)
{
  float d,x,y;

  do {
    // lose one or both remaps (2*rng_f32()-1)
    // for uniform half or quarter disc
    x = 2.f*rng_f32()-1.f;    // (-1,1)
    y = 2.f*rng_f32()-1.f;    // (-1,1)
    d = x*x + y*y;            // p.p
  } while(d >= 1.f);          // branch prob: 1-pi/4 ~= 0.214602

  p->x = x;
  p->y = y;

  return d;                   // p.p
}
{% endhighlight %}

\\
By dropping one of the range remapping of $x$ or $y$ give a uniform distribution on the half disc and dropping both the quarter disc.  The efficiency of the these are identical to the full disc case.

<div id="disc" style="width:100%">
<button onclick="javascript:newDisc( 125);">125</button>
<button onclick="javascript:newDisc( 250);">250</button>
<button onclick="javascript:newDisc( 500);">500</button>
<button onclick="javascript:newDisc(1000);">1000</button>
<button onclick="javascript:newDisc(2000);">2000</button>
</div>

<br>

#### Ad-hoc non-uniform

If we rescale the component by some function of the dot product $d = (p \cdot p)$ we can get radial ad-hoc non-uniform distributions.

Directly scaling by the dot-product:

<div id="discnu" style="width:100%">
<button onclick="javascript:newDisc1( 125);">125</button>
<button onclick="javascript:newDisc1( 250);">250</button>
<button onclick="javascript:newDisc1( 500);">500</button>
<button onclick="javascript:newDisc1(1000);">1000</button>
<button onclick="javascript:newDisc1(2000);">2000</button>
</div>
  
  
\\
Scaling by $\frac{d}{1+d}$:

<div id="disc2" style="width:100%">
<button onclick="javascript:newDisc2( 125);">125</button>
<button onclick="javascript:newDisc2( 250);">250</button>
<button onclick="javascript:newDisc2( 500);">500</button>
<button onclick="javascript:newDisc2(1000);">1000</button>
<button onclick="javascript:newDisc2(2000);">2000</button>
</div>

------

Uniform points on unit circle <small>or uniform 2D rotation</small>
------

\\
Like the disc case we can generate a uniform point on the unit circle (1-sphere or $\mathbb{S}^1$) using trigonometry and symmetry/identities to reduce runtime complexity.


$$ \left(\cos\left(\theta\right), ~\sin\left(\theta\right)\right) $$


\\
In the same paper[^jvnCircle] as the disc rejection method John von Neumann presented a pair of techinques to transform uniform points on the unit disc to uniform points on the circle.  If we have a uniform point $p = \left(x,y \right)$ (considered as a complex number) on the unit disc, then the first method is to simply normalize:


$$ \left\Vert p \right\Vert = \frac{p}{\sqrt{p \cdot p}} = \frac{1}{\sqrt{x^2+y^2}}  \left(x, y \right)$$

\\
The second method observes that squaring drops the square root and since it doubles the angle maintains uniformity.

$$ \left\Vert p \right\Vert^2 = \frac{p^2}{p \cdot p} = \frac{1}{x^2+y^2}  \left(x^2-y^2, 2xy \right)$$

\\
The second method is widely known since it trades a square root for two products and two additions which historically was an assured win.  With the introduction of fast inverse square root approximations the lesser known normalization method becomes interesting.  Also choosing between zero, one or two NR iterations give a knob of speed vs. bias of the result.

The remaining issue with a practical implementation is the degenerate case.  I'll assume that uniform float values are generated by "equidistance" method (pretty much the only one used).  This method will generates values: $\frac{u}{2^{24}}$ where $u$ is a uniform integer on $\left[ 0, 2^{24} \right)$.  The only problem result is then when both are zero. We can correct inverse square root by introducing a bias to the dot product which is sufficiently small that only contributes when both are zero such as $2^{-72}$.  We also need to project that input to unit circle which requires choosing the branch point for the origin.  Let's send it to $(1,0)$ which needs adding a bias to the $x$ coordinate.  This gives us:


{% highlight c %}
#define BIAS (1.f/68719476736.f) // 0x1p-36f

void uniform_s1(vec2_t* p)
{
  float d = uniform_disc(p);
  float s = rsqrt(d+(BIAS*BIAS));  // 1/sqrt approx + X NR steps
  p->x += BIAS;                    // map (0,0) -> (1,0)
  p->x *= s;
  p->y *= s;
}
{% endhighlight %}

\\
Since we're simply normalizing we can create half and quarter circles as per same disc above.

<div id="circle" style="width:100%">
<button onclick="javascript:newCircle( 25);">25</button>
<button onclick="javascript:newCircle( 50);">50</button>
<button onclick="javascript:newCircle(100);">100</button>
<button onclick="javascript:newCircle(200);">200</button>
</div>
  
  <br>
  
#### Ad-hoc non-uniform

Taking the uniform variants and applying some simple transforms can yield some potentially interesting non-uniform distributions.  If we take a uniform disc, translate it by one in x and then normalize we get a distribution that is roughly normal (standard deviation ~0.615113) on $\left[-\frac{\pi}{2},\frac{\pi}{2}\right] $  Using the angle-doubling version, well, doubles the angle output range.

<div id="pdf1" style="width:100%"></div>


<br>

------

Uniform points on the 3D unit sphere 
------

\\
In 1972 George Marsaglia[^gm] introduced a method to transform a uniform point on the unit disc to a uniform point on the 3D sphere $\left(\mathbb{S}^2\right)$:

$$
   \left(2x\sqrt{1-\left(x^2+y^2\right)},~2y\sqrt{1-\left(x^2+y^2\right)},~1-2\left(x^2+y^2\right)\right)
$$

\\
I walked through to this equation in the post *"Implied normals (unit bivectors as rotations)"*[^inormals] where it's described as the sequence: orthogonal project disc to half-sphere followed by a double-angle transform.  Some bullet points are:

* an area-preserving map from disc to sphere (equivalent to Lamberts)
* radial lines (through origin) on disc are mapped to longitude circles on sphere (angle measure maintained)
* circles are mapped to latitudes (see below)
* $\left( 0, ~0 \right) $ is mapped to the north pole
* the disc: $r \in \left[ 0,  ~\frac{1}{\sqrt{2}} \right] $ is mapped to the positive half sphere $\left( \mathbf{z} \geq 0 \right) $
* the annulus: $r \in \left( \frac{1}{\sqrt{2}}, ~1 \right) $ is mapped to the negative half sphere $\left( \mathbf{z} < 0 \right )$
* all points on the unit circle are mapped to south pole

<br>
{% highlight c %}
void uniform_s2(vec3_t* p)
{
  float d,s;
  vec2_t v;

  d = uniform_disc(&v);
  s = 2.f*sqrtf(1.f-d);
  p->x = s*v.x;
  p->y = s*v.y;
  p->z = 1.f-2.f*d;
}
{% endhighlight %}
     
<br>
  
Given how points are mapped from the disc to the sphere, if we knew what "what circle maps to which latitude" we could form rotationally symettric distributions on the sphere directly from those on the disc.  Dropping the angle-doubling map we end up with a cosine distribution on the half-sphere.

<br>

------

Spherical caps
------

As with non-uniform distributions, given the way the disc is mapped to the sphere we can directly formulate uniform points on spherical caps. The areas of the disc, sphere and spherical cap (height $h$) are respectively:

$$
A_d = \pi r^2   \\
A_s = 4\pi r^2  \\
A_c = 2\pi r h
$$

So the mapping from disc to sphere involves a constant factor of four and the area of the cap is linear with height. So we can form a point set on the unit disc, apply a uniform scaling and apply the disc to sphere mapping.  The cap has a radius of one, divide out the constant factor of the disc to sphere map and relate the areas:

$$ \frac{2\pi h}{4} = \pi r^2$$

Solving for $r$ give us:

$$ r = \sqrt{\frac{h}{2}} $$

Plugging this scale factor into the map gives us the direct formulation:

$$
   \left(x\sqrt{h\left(2-h\left(x^2+y^2\right)\right)},~y\sqrt{h\left(2-h\left(x^2+y^2\right)\right)},~1-h\left(x^2+y^2\right)\right)
$$

{% highlight c %}
void uniform_s2_cap(vec3_t* p, float h)
{
  float k,s;
  vec2_t v;

  k = h*uniform_disc(&v);   // h(x^2+y^2)
  s = sqrtf(h*(2.f-k));     // sqrt( h(2-h(x^2+y^2)) )
  p->x = s*v.x;
  p->y = s*v.y;
  p->z = 1.f-k;
}
{% endhighlight %}


<br>

------

Extra examples
------

\\
Started this section to be able to add extra examples.

   <br>
   <br>
   
#### Cosine distribution on half-circle
   
\\
Generating a uniform line and projecting to circle results in $P(\theta) = \frac{1}{2}\cos(\theta)$.

{% highlight c %}
void cosine_s1(vec3_t* p)
{
  float y = 2.f*rng_f32()-1.f;    // (-1,1)
  float x = sqrtf(1.f-y*y);
  p->x = x;
  p->y = y;
}
{% endhighlight %}


<br>

#### Cosine distribution on half-sphere

\\
Seemingly the most common fragment shader version is as follows:

{% highlight glsl %}
vec3 cosDistHalfSphere(in vec3 n , in float seed) 
{
  float d2 = rng(seed++);
  float a  = 2.0*PI*rng(seed++));

  // an orthonormal basis (complement of 'n')
  vec3  uu = normalize(cross(n,vec3(0,1,1)));
  vec3  vv = cross(uu, n);

  // generate a uniform point on disc (trig method)
  // p = ra(rx,ry)
  float ra = sqrt(d2);
  float rx = cos(a); 
  float ry = sin(a);
  
  // project to sphere (Z)
  float rz = sqrt(1.0-d2);

  // map 'p' to generated basis: ra*(rx*uu + ry*vv)
  // map 'z' to 'n':             rz*n
  return normalize(ra*(rx*uu + ry*vv) + rz*n);
}
{% endhighlight %}

\\
Note that the basis computation is degenerate as 'n' approaches $\pm \frac{1}{2}\left(0, \sqrt{2}, \sqrt{2}\right)$ and this requires the otherwise unneeded normalization of the final result to reduce the degenerate zone.

So one option is use a method without a degenerate case[^ortho]:

{% highlight glsl %}
vec3 cosDistHalfSphere(in vec3 n , in float seed) 
{
  float d2 = rng(seed++);
  float a  = 2.0*PI*rng(seed++));
  
  // some alternate non-degenerate method
  // see post including links
  float sz = n.z >= 0.0 ? 1.0 : -1.0;
  float a  =  n.y/(1.0+abs(n.z));
  float b  =  n.y*a;
  float c  = -n.x*a;
  vec3  uu = vec3(n.z+sz*b, sz*c, -n.x);
  vec3  vv = vec3(c, 1.0-b, -sz*n.y);
	
  float ra = sqrt(d2);
  float rx = cos(a); 
  float ry = sin(a);
  float rz = sqrt(1.0-d2);

  return ra*(rx*uu + ry*vv) + rz*n;
}
{% endhighlight %}


<br>

------

References and Footnotes
------

[^mwDisc]:    *"Disk Point Picking"*, Eric W. Weisstein, [MathWorld](http://mathworld.wolfram.com/DiskPointPicking.html)
[^mwCircle]:  *"Circle Point Picking"*, Eric W. Weisstein, [MathWorld](http://mathworld.wolfram.com/CirclePointPicking.html)
[^jvnCircle]: *"Various Techniques Used in Connection With Random Digits"*, John von Neumann, 1951 ([PDF](https://dornsifecms.usc.edu/assets/sites/520/docs/VonNeumann-ams12p36-38.pdf))
[^inormals]: *"Implied normals (unit bivectors as rotations)"*, ([local post]({{site.base}}/quaternions/2016/06/26/QuatNormal.html))
[^gm]:       *"Choosing a Point from the Surface of a Sphere"*, George Marsaglia, 1972 ([PDF](http://projecteuclid.org/euclid.aoms/1177692644))
[^ortho]:    *"Orthonormal basis from normal via quaternion similarity"*, ([local post]({{site.base}}/quaternions/2016/07/06/Orthonormal.html))


<script>


var axisDef = { showgrid: false, showline: false, zeroline: false, range:[-1.2, 1.2], fixedrange: true };
var markDef = { size:4, color:'6565FF'};
var plotType = 'scatter';


function disc(n)
{
  var d,x,y;
  var rx = [];
  var ry = [];
  var rd = [];

  for (var i=0; i<=n; i++) {
    do {
      x = 2.0*Math.random()-1.0;
      y = 2.0*Math.random()-1.0;
      d = x*x + y*y;
    } while(d >= 1);
	rx.push(x);
	ry.push(y);
	rd.push(d);
  }

  return [rx,ry,rd];
}

function disc_d2(n) {
  var d,x,y;
  var rx = [];
  var ry = [];

  for (var i=0; i<=n; i++) {
    do {
      x = 2.0*Math.random()-1.0;
      y = 2.0*Math.random()-1.0;
      d = x*x + y*y;
    } while(d >= 1);
	
	d = 2/(1+d);
	
	rx.push(x*d);
	ry.push(y*d);
  }

  return [rx,ry];
}


function disc_d(n)
{
  var d,x,y;
  var rx = [];
  var ry = [];

  for (var i=0; i<=n; i++) {
    do {
      x = 2.0*Math.random()-1.0;
      y = 2.0*Math.random()-1.0;
      d = x*x + y*y;
    } while(d >= 1);
	rx.push(x*d);
	ry.push(y*d);
  }

  return [rx,ry];
}

var bias = (1.0/68719476736.0);

function circle(n)
{
  var d,x,y;
  var rx = [];
  var ry = [];

  for (var i=0; i<=n; i++) {
    do {
      x = 2.0*Math.random()-1.0;
      y = 2.0*Math.random()-1.0;
      d = x*x + y*y;
    } while(d >= 1);
	d = 1.0/Math.sqrt(d + bias*bias);
	rx.push(d*(x+bias));
	ry.push(d*y);
  }

  return [rx,ry];
}

function circlepn(n)
{
  var d,x,y;
  var rx = [];
  var ry = [];

  for (var i=0; i<=n; i++) {
    do {
      x = 2.0*Math.random()-1.0;
      y = 2.0*Math.random()-1.0;
      d = x*x + y*y;
    } while(d >= 1);
	
	
	
	d = 1.0/Math.sqrt(d + bias*bias);
	rx.push(d*(x+bias));
	ry.push(d*y);
  }

  return [rx,ry];
}


// build a reference unit circle (100 points)
var unitCircle;

{
  var cX=[];
  var cY=[];

  for(var t=-Math.PI; t<=Math.PI; t+=(Math.PI/100)) {
    var x = Math.cos(t);
    var y = Math.sin(t);
    cX.push(x);
    cY.push(y);
  }
  
  unitCircle = {x:cX, y:cY, type:plotType, mode:'line', name:'unit circle', line: {color: 'C0C0FF'}};
}

var junk;
var disc0Set, disc1Set, disc2Set;

// create new uniform disc point set plot with 'n' points
function makeDisc(n) {
  var p = disc(n);
  disc0Set = { x:p[0], y:p[1], type:plotType, mode:'markers', marker:markDef, name:'point set' };
}

// create new and animate
function newDisc(n) {
  makeDisc(n);
  Plotly.animate('disc', {data: [unitCircle, disc0Set] }, 
  { transition: { duration: 500, ease: 'cubic-in-out'  }})
}

function makeDisc1(n) {
  var p = disc_d(n);
  disc1Set = { x:p[0], y:p[1], type:plotType, mode:'markers', marker:markDef, name:'point set' };
}

function newDisc1(n) {
  makeDisc1(n);
  Plotly.animate('discnu', {data: [unitCircle, disc1Set] }, 
  { transition: { duration: 500, ease: 'cubic-in-out'  }})
}

function makeDisc2(n) {
  var p = disc_d2(n);
  disc2Set = { x:p[0], y:p[1], type:plotType, mode:'markers', marker:markDef, name:'point set' };
}

function newDisc2(n) {
  makeDisc2(n);
  Plotly.animate('disc2', {data: [unitCircle, disc2Set] }, 
  { transition: { duration: 500, ease: 'cubic-in-out'  }})
}

function makeCircle(n) {
  var p = circle(n);
  circleSet = { x:p[0], y:p[1], type:plotType, mode:'markers', marker:markDef, name:'point set' };
}

function newCircle(n) {
  makeCircle(n);
  Plotly.animate('circle', {data: [unitCircle, circleSet] }, 
  { transition: { duration: 500, ease: 'cubic-in-out'  }})
}



// create inital point sets
makeDisc(1000); 
makeDisc1(1000); 
makeDisc2(1000); 

junk = circle(100);
var circleSet = { x:junk[0], y:junk[1], type:plotType, mode:'markers', marker:markDef, name:'point set' };

var disc0Data  = [unitCircle, disc0Set ];
var disc1Data  = [unitCircle, disc1Set ];
var disc2Data  = [unitCircle, disc2Set ];
var circleData = [unitCircle, circleSet];

// some hackiness to approximate square aspect ratio, since I couldn't figure it out.
var discLayout = {
  xaxis:  axisDef,
  yaxis:  axisDef,
  height: 600,
  width:  630,
  //aspectmode: 'data',
  hovermode: !1
};

var options = {displaylogo: false, autosizable: true};

Plotly.newPlot('disc',   disc0Data,  discLayout, options);
Plotly.newPlot('discnu', disc1Data,  discLayout, options);
Plotly.newPlot('disc2',  disc2Data,  discLayout, options);
Plotly.newPlot('circle', circleData, discLayout, options);


function normaldist(x) { return 0.648567*Math.exp(-1.32148*x*x); }
var npdf1;

{
  var cX=[];
  var cY=[];

  for(var t=-Math.PI*.5; t<=Math.PI*.5; t+=(Math.PI/100)) {
    cX.push(t);
    cY.push(normaldist(t));
  }
  
  npdf1 = {x:cX, y:cY, type:plotType, mode:'line', name:'normal'};//, line: {color: 'C0C0FF'}};
}


var y1 = [0.000025, 0.0015,   0.006325, 0.0137,   0.0246,   0.038275, 0.0549,   0.073325,
          0.096425, 0.115175, 0.1433,   0.174,    0.2018,   0.230675, 0.262925, 0.29375,
		  0.3238,   0.35955,  0.386575, 0.42235,  0.4548,   0.4727,   0.502625, 0.527075,
		  0.5489,   0.567475, 0.593425, 0.606325, 0.60805,  0.6277,   0.630975, 0.632375,
		  0.638425, 0.629,    0.623375, 0.622025, 0.61125,  0.582775, 0.5698,   0.548175,
		  0.531075, 0.50545,  0.474975, 0.4468,   0.419175, 0.384275, 0.358275, 0.3268,
		  0.29745,  0.2643,   0.230775, 0.20005,  0.1708,   0.1455,   0.1189,   0.09315,
		  0.07335,  0.055525, 0.038325, 0.024475, 0.012675, 0.00615,  0.0015,   0.000025];

var x1 = [-1.575, -1.525, -1.475, -1.425, -1.375, -1.325, -1.275, -1.225,
-1.175, -1.125, -1.075, -1.025, -0.975, -0.925, -0.875, -0.825, 
-0.775, -0.725, -0.675, -0.625, -0.575, -0.525, -0.475, -0.425, 
-0.375, -0.325, -0.275, -0.225, -0.175, -0.125, -0.075, -0.025, 
0.025, 0.075, 0.125, 0.175, 0.225, 0.275, 0.325, 0.375, 0.425, 0.475,
0.525, 0.575, 0.625, 0.675, 0.725, 0.775, 0.825, 0.875, 0.925, 0.975,
1.025, 1.075, 1.125, 1.175, 1.225, 1.275, 1.325, 1.375, 1.425, 1.475,
1.525, 1.575];

var pdf1 = { x: x1, y: y1, name: 'empirical', opacity: 0.5,  type: "bar" };

var pdf1data = [pdf1,npdf1];

var pdf1layout = {
  bargap: 0.05, 
  bargroupgap: 0.2, 
  barmode: "overlay", 
  xaxis: {title: "PDF"}, 
};

Plotly.newPlot('pdf1', pdf1data, pdf1layout);




</script>

<br>
